#!/usr/bin/env perl

sub getPath {
	my ($url) = @_;
	my @parts = split(m|/|, $url);
	pop @parts;
	unshift @parts, "./" if (@parts == 0);
	return join('/', @parts).'/';
}

use lib getPath($0)."../lib/";

use strict;
use warnings;
use Data::Dumper;
use foldGrammars::Settings;
use foldGrammars::Utils;
use foldGrammars::References;
use foldGrammars::RapidShapes;
use foldGrammars::IO;
use Getopt::Long;
use POSIX 'isatty';

my $settings = {};
foreach my $param (keys %RapidShapes::PARAM) {
	$settings->{$param} = $RapidShapes::PARAM{$param}->{default};
}
my %help = ();
foreach my $param (keys %RapidShapes::PARAM) {
	my $optionSec = $RapidShapes::PARAM{$param}->{key};
	$optionSec .= "=".$RapidShapes::PARAM{$param}->{type} if (exists $RapidShapes::PARAM{$param}->{type});
	$help{$optionSec} = \$settings->{$param};
}
&GetOptions( 	
	%help
);

RapidShapes::checkParameters($settings, \%RapidShapes::PARAM);

if (defined $settings->{'cluster'}) {
	Utils::applyFunctionToFastaFile($settings->{'cluster'}, \&doComputation, $settings);
} else {
	if (@ARGV == 0) {
		if (defined $settings->{'help'}) {
			RapidShapes::usage();
		} else {
			if (isatty(*STDIN)) {
				print "waiting for your plain RNA sequence or fasta filename.\n";
				my $input = <STDIN>; chomp $input;
				if (-e $input) {
					Utils::applyFunctionToFastaFile($input, \&doComputation, $settings);
				} else {
					my %sequence = ("header", "unnamed sequence 1", "sequence", $input);
					doComputation(\%sequence, $settings);
				}
			} else {
				Utils::applyFunctionToFastaFile(\*STDIN, \&doComputation, $settings);
			}
		}
	} else {
		RapidShapes::usage() if ((defined $settings->{'help'}) || (@ARGV > 1));
		my ($input) = @ARGV;
		if (-e $input) {
			Utils::applyFunctionToFastaFile($input, \&doComputation, $settings);
		} else {
			my %sequence = ("header", "unnamed sequence 1", "sequence", $input);
			doComputation(\%sequence, $settings);
		}
	}
}

sub doComputation {
	my ($refHash_sequence, $settings) = @_;
	
	if ($refHash_sequence->{sequence} !~ m/^\s*((A|C|G|U|T)+)\s*$/i) {
		print STDERR "sequence '".$refHash_sequence->{header}."' has been skipped, due to non RNA letter. Only A,C,G,U,T,a,c,g,u,t are allowed.";
	}
	my $seq = $refHash_sequence->{sequence};
	$seq =~ s/t/u/gi;

	my $workingDirectory = qx(pwd); chomp $workingDirectory;
	if (defined $settings->{cluster}) {
		my ($fastaDir, $fastaFile) = @{Utils::separateDirAndFile($settings->{cluster})};
		
		my $errDir = $workingDirectory.'/'.$fastaFile.'.cluster/ERR';
		my $outDir = $workingDirectory.'/'.$fastaFile.'.cluster/OUT';
		my $reformattedFastafile = $workingDirectory.'/'.$fastaFile.'.cluster/'.$fastaFile;
		my $arrayJob =  $workingDirectory.'/'.$fastaFile.'.cluster/array.sh';
		
		qx(mkdir -p $errDir) if (not -d $errDir);
		qx(mkdir -p $outDir) if (not -d $outDir);
		open (FASTA, "> ".$reformattedFastafile) || die "cannot write to '$reformattedFastafile': $1";
			my @count = @{Utils::applyFunctionToFastaFile($settings->{cluster}, \&reformatFasta, \*FASTA)};
		close (FASTA);
		
		open (ARRAY, "> ".$arrayJob) || die "cannot write to '$arrayJob': $1";		
			print ARRAY '#!'.$Settings::BINARIES{sh}."\n";
			print ARRAY ''."\n";
			print ARRAY '#$ -S '.$Settings::BINARIES{sh}."\n";
			print ARRAY '#$ -t 1-'.@count."\n";
			print ARRAY '#$ -N RapidShapes_'.$fastaFile."\n";
			print ARRAY '#$ -e '.$errDir."\n";
			print ARRAY '#$ -o '.$outDir."\n";
			print ARRAY ''."\n";
			print ARRAY 'sequenceFile='.$reformattedFastafile."\n";
			print ARRAY 'headerpos=`'.$Settings::BINARIES{echo}.' "($SGE_TASK_ID-1)*3+1" | '.$Settings::BINARIES{bc}.'`; '."\n";
			print ARRAY 'sequencepos=`'.$Settings::BINARIES{echo}.' "($SGE_TASK_ID-1)*3+2" | '.$Settings::BINARIES{bc}.'`; '."\n";
			print ARRAY 'header=`'.$Settings::BINARIES{head}.' -n $headerpos $sequenceFile | '.$Settings::BINARIES{tail}.' -1`; '."\n";
			print ARRAY 'sequence=`'.$Settings::BINARIES{head}.' -n $sequencepos $sequenceFile | '.$Settings::BINARIES{tail}.' -1`;'."\n";
			print ARRAY 'uname -a'."\n";
			my $command = "";
			foreach my $param (keys %{$settings}) {
				next if (($param eq 'name') || ($param eq 'cluster') || ($param eq 'binPath'));
				$command .= " --".$RapidShapes::PARAM{$param}->{key}.'="'.$settings->{$param}.'"' if (defined $settings->{$param});
			}
			$command .= ' --binPath="'.$workingDirectory.'/'.$fastaFile.'.cluster/"';
			$command .= ' --name="$header"';
			$command .= '  "$sequence"';
			print ARRAY $Settings::BINARIES{perl}." ".Utils::absFilename($0)." ".$command."\n";
		close (ARRAY);
		
		my $bin_tdmGenerator = getCompilerBinary($settings);
		
		my $arch = '-l arch="sol-amd64"';
		$arch = '-l linh=1' if (qx($Settings::BINARIES{uname} -o) !~ m/Sun/i);
		print "array job has been created, submit it to the grid via e.g.\nqsub -cwd -l virtual_free=17G $arch $arrayJob\n";
	} else {
		#1) guess shape classes via stochastical backtracing (default) or simple shape analysis, where shapes are sorted according to their shrep free energy
			my @shapes = ();
			if ($settings->{mode} eq $Settings::MODE_KBEST) {
				@shapes = @{RapidShapes::guessShapesKbest($seq, $settings)};
			} elsif ($settings->{mode} eq $Settings::MODE_SUBOPT) {
				@shapes = @{RapidShapes::guessShapesSubopt($seq, $settings)};
			} elsif ($settings->{mode} eq $Settings::MODE_LIST) {
				@shapes = @{$settings->{list}};
				print STDERR "step 1: using a provided list of ".@shapes." shapes.\n";		
			} else {
				@shapes = @{RapidShapes::guessShapesSampling($seq, $settings)};
			}

		#2) determining partition function value for complete search space	
			my $pfAll = RapidShapes::getPFall($seq, $settings);
			
		#3) compile TDM generator if not available
			print STDERR "step 3: compute exact probabilities for guessed shapes:\n";
			my $bin_tdmGenerator = getCompilerBinary($settings);
			my $pfShapeSum = 0;
			my %waitList = ();
			foreach my $shape (@shapes) {
				my $ljshape = $shape->{shapestring};
				$ljshape =~ s/\[/L/g;
				$ljshape =~ s/\]/J/g;
				print STDERR "\t".$shape->{shapestring}."\tcompiling ... ";
				my $pfShape = Utils::compileAndrunTDM($shape->{shapestring}, $settings, $refHash_sequence, undef);
				foreach my $line (split(m/\n/, $pfShape)) {
					if ($line =~ m/\( \( (.+?) , \( (.+?) , (.+?) \) \) , \( (.+?) , (.+?) \) \)$/) {
						#( ( [] , ( -2340 , 2.62995e+11 ) ) , ( (((((((..........((((........))))..))))))).... , 3.2736e+10 ) )
						$shape->{answer} = {energy => $2/100, pfValue => $3, structure => $4, pfStructure => $5, probability => $3/$pfAll};
						$pfShapeSum += $shape->{answer}->{pfValue};
						$waitList{$shape->{shapestring}}->{answer} = {energy => $2/100, pfValue => $3, structure => $4, pfStructure => $5};
						print STDERR sprintf("%8.4f", $shape->{answer}->{probability}*100)." %.\n";
						last;
					}
				}
				if ($pfShapeSum / $pfAll >= $settings->{alpha}) {
					print STDERR "discovered more than the required ".sprintf("%.2f", $settings->{alpha}*100)." % of the folding space. Skip remaining shapes.\n";
					foreach my $skippedShape (@shapes) {
						$skippedShape->{answer}->{probability} = 0 if (not exists $skippedShape->{answer}->{probability});
					}
					last;
				}
			}
			print STDERR "\n";
			
		#Output Results the same way RNAshapes does
			RapidShapes::commandlineOutput($refHash_sequence, $settings, \%waitList, $pfAll);
	}	
}





sub getCompilerBinary {
	my ($refHash_settings) = @_;
	return Utils::absFilename($refHash_settings->{binarypath}.$refHash_settings->{binaryprefix}.'tdm_'.$refHash_settings->{grammar}.'_'.$refHash_settings->{shapelevel});
}


	

	


sub runTDM {
	my ($tmpDir, $refHash_settings, $inputSequence) = @_;
	print STDERR "done.\texecuting ... "; 
	my $command = RapidShapes::buildCommand($refHash_settings, $RapidShapes::TASK_TDMRUN);
	my $inputFile = Utils::writeInputToTempfile($inputSequence);
	my $pfShape = RapidShapes::parsePFanswer(qx($tmpDir/$command -f $inputFile));
	unlink $inputFile;
	return $pfShape;
}



sub reformatFasta {
	my ($refHash_sequence, $refFileHandle) = @_;
	print $refFileHandle ">".$refHash_sequence->{header}."\n".$refHash_sequence->{sequence}."\n\n";
	return undef;
}







