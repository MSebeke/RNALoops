#!/usr/bin/env perl

sub getPath {
	my ($url) = @_;
	my @parts = split(m|/|, $url);
	pop @parts;
	unshift @parts, "./" if (@parts == 0);
	return join('/', @parts).'/';
}

use lib getPath($0)."../lib/";

use strict;
use warnings;
use Data::Dumper;
use foldGrammars::Settings;
use foldGrammars::Utils;
use foldGrammars::References;
use foldGrammars::RapidShapes;
use Getopt::Long;
use POSIX 'isatty';
use File::Temp qw/ tempfile tempdir /;

my $gridID = undef;


#if we catch a SIGINT, we eventually delete running cluster jobs.
$SIG{INT} = sub {
	if (defined $gridID) {
		system $Settings::BINARIES{qdel}." ".$gridID;
	}
	print STDERR "Program terminated.\n";
	exit 1;
};

my $settings = {};
foreach my $param (keys %RapidShapes::PARAM) {
	$settings->{$param} = $RapidShapes::PARAM{$param}->{default};
}
my %help = ();
foreach my $param (keys %RapidShapes::PARAM) {
	my $optionSec = $RapidShapes::PARAM{$param}->{key};
	$optionSec .= "=".$RapidShapes::PARAM{$param}->{type} if (exists $RapidShapes::PARAM{$param}->{type});
	$help{$optionSec} = \$settings->{$param};
}
&GetOptions( 	
	%help
);

RapidShapes::checkParameters($settings, \%RapidShapes::PARAM);

#For BiBiServ the input comes as a file path name
my ($input) = @ARGV;
if (defined $settings->{'help'}) {
	RapidShapes::usage();
}
if (-e $input) {
	Utils::applyFunctionToFastaFile($input, \&doComputation, $settings);
} else {
	RapidShapes::usage();
}

sub generateHTMLstatuspage {
	my ($refHash_sequence, $settings, $refHash_shapes, $pfAll) = @_;

	my $guessMethod = "";
	my $methodHeader = "";
	if ($settings->{mode} eq $Settings::MODE_SAMPLE) {
		$guessMethod = "sampling";
		$methodHeader = "frequency";
	} elsif ($settings->{mode} eq $Settings::MODE_KBEST) {
		$guessMethod = "k-best";
		$methodHeader = "free energy";
	} elsif ($settings->{mode} eq $Settings::MODE_LIST) {
		$guessMethod = "manual list";
		$methodHeader = "list position";
	} elsif ($settings->{mode} eq $Settings::MODE_SUBOPT) {
		$guessMethod = "suboptimals";
		$methodHeader = "free energy";
	}

	my %status_overall = ();
	$status_overall{label} = "start computation.";
	$status_overall{style} = "running";
	my %status_guessing = ();
	$status_guessing{label} = 'running';
	$status_guessing{style} = 'running';
	if (scalar(keys(%{$refHash_shapes})) > 0) {
		$status_guessing{label} = scalar(keys(%{$refHash_shapes}))." shapes";
		$status_guessing{style} = 'finish';
	}
	
	if ($status_guessing{style} eq 'running') {
		$status_overall{label} = "phase 1) guessing shapes ...";
		$status_overall{style} = "running";
	}

	my %status_pfall = ();
	$status_pfall{label} = 'pending';
	$status_pfall{style} = 'pending';
	if ((scalar(keys(%{$refHash_shapes})) > 0) && (not (defined $pfAll))) {
		$status_pfall{label} = 'running';
		$status_pfall{style} = 'running';
		$status_overall{label} = "phase 2) computing overall partition function ...";
		$status_overall{style} = "running";
	}
	if (defined $pfAll) {
		$status_pfall{label} = $pfAll;
		$status_pfall{style} = 'finish';
	}
	
	my $exploredPF = 0;
	my $exploredTDMs = 0;
	my $exploredPart = 0;
	foreach my $shape (sort (keys(%{$refHash_shapes}))) {
		if (exists $refHash_shapes->{$shape}->{pfAnswer}) {
			$exploredPF += $refHash_shapes->{$shape}->{pfAnswer};
			$exploredTDMs++;
		}
	}
	$exploredPart = $exploredPF / $pfAll if (defined $pfAll && $pfAll > 0);
	if (($exploredPart >= 0) && (scalar(keys(%{$refHash_shapes})) > 0)) {
		$status_overall{label} = "phase 3) compiling and executing TDMs ...";
		$status_overall{style} = "running";
	}
	if ($exploredPart >= $settings->{alpha}) {
		$status_overall{label} = "finished.";
		$status_overall{style} = "finish";
	}
	my %status_tdms = ();
	$status_tdms{label} = sprintf("%.".$settings->{probdecimals}."f", $exploredPart)." %";
	$status_tdms{style} = 'pending';
	$status_tdms{style} = 'running' if (scalar(keys(%{$refHash_shapes})) > 0);
	$status_tdms{style} = 'finish' if ($exploredPart >= $settings->{alpha});
	
	my $HTML = "<html><head><link rel='stylesheet' type='text/css' href='status.css' /> </head><body>";
	
	$HTML .= "<table border='0'>";
	$HTML .= "<tr><th colspan='3'>Overall status: ".printStatus(\%status_overall)."</th></tr>";
	$HTML .= "<tr><td>1) guessing shapes: ".printStatus(\%status_guessing)."</td><td>2) PF all: ".printStatus(\%status_pfall)."</td><td>3) analyzed ".$exploredTDMs." / ".scalar(keys(%{$refHash_shapes}))." TDMs = ".printStatus(\%status_tdms)." foldingspace</td></tr>";
	$HTML .= "</table>";
	
	$HTML .= "<table border='1' class='metainfo'>";
	$HTML .= "<tr><th>Header</th><td>".$refHash_sequence->{header}."</td></tr>";
	$HTML .= "<tr><th>Sequence</th><td>";
	my $seq = $refHash_sequence->{sequence};
	my $wrapAtChar = $Settings::RAPIDSHAPES_BIBISERV{wrapInputSequenceAfterChars};
	while (length($seq) > $wrapAtChar) {
		$HTML .= substr($seq, 0, $wrapAtChar)."<br/>";
		$seq = substr($seq, $wrapAtChar);
	}
	$HTML .= $seq;
	$HTML .= "</td></tr>";
	$HTML .= "<tr><th>Sequence length</th><td>".length($refHash_sequence->{sequence})." nucleotides</td></tr>";
	$HTML .= "<tr><th>alpha threshold</th><td>".($settings->{alpha}*100)." %</td></tr>";
	$HTML .= "<tr><th>Shape level</th><td>".$settings->{shapelevel}."</td></tr>";
	$HTML .= "<tr><th>Grammar</th><td>".$settings->{grammar}."</td></tr>";
	$HTML .= "<tr><th>lonely pairs</th><td>".($settings->{allowlp} == 0 ? "not allowed" : "allowed")."</td></tr>";
	$HTML .= "<tr><th>temperature</th><td>".$settings->{temperature}." &deg;C</td></tr>";
	my $paramName = "rna_turner2004.par";
	if (defined $settings->{param}) {
		$paramName = qx($Settings::BINARIES{basename} $settings->{param});
		chomp $paramName;
	}
	$HTML .= "<tr><th>parameter</th><td>".$paramName."</td></tr>";
	$HTML .= "<tr><th>Guessing method</th><td>".$guessMethod."</td></tr>";
	$HTML .= "</table>";
	
	$HTML .= "<table border='1'>";
	$HTML .= "<tr><th>Shape</th><th>TDM generation</th><th>TDM execution</th><th>Shape probability</th><th>".$methodHeader."</th><th>Partition function value</th></tr>";
	foreach my $shape (sort {$refHash_shapes->{$a}->{position} <=> $refHash_shapes->{$b}->{position}} (keys(%{$refHash_shapes}))) {
		my %status_generation = ();
		$status_generation{label} = 'pending';
		$status_generation{style} = 'pending';
		if ($refHash_shapes->{$shape}->{status} eq 'compiling') {
			$status_generation{label} = 'running';
			$status_generation{style} = 'running';
		}
		if (exists $refHash_shapes->{$shape}->{compiletime}) {
			$status_generation{label} = "finished (".sprintf("%.1f",$refHash_shapes->{$shape}->{compiletime})."s)";
			$status_generation{style} = 'finish';
		}
		if ($refHash_shapes->{$shape}->{status} eq 'stopped') {
			$status_generation{label} = "stopped";
			$status_generation{style} = 'stopped';
		}
		
		my %status_execution = ();
		$status_execution{label} = 'pending';
		$status_execution{style} = 'pending';
		if ($refHash_shapes->{$shape}->{status} eq 'running') {
			$status_execution{label} = 'running';
			$status_execution{style} = 'running';
		}
		if (exists $refHash_shapes->{$shape}->{runtime}) {
			$status_execution{label} = "finished (".sprintf("%.1f",$refHash_shapes->{$shape}->{runtime}).")";
			$status_execution{style} = 'finish';
		}
		if ($refHash_shapes->{$shape}->{status} eq 'stopped') {
			$status_execution{label} = "stopped";
			$status_execution{style} = 'stopped';
		}
		
		my $cell = "";
		if ($settings->{mode} eq $Settings::MODE_SAMPLE) {
			$cell = sprintf("%.".$settings->{probdecimals}."f", $refHash_shapes->{$shape}->{frequency})." %";
		} elsif ($settings->{mode} eq $Settings::MODE_KBEST) {
			$cell = $refHash_shapes->{$shape}->{mfe};
		} elsif ($settings->{mode} eq $Settings::MODE_LIST) {
			$cell = $refHash_shapes->{$shape}->{position};
		} elsif ($settings->{mode} eq $Settings::MODE_SUBOPT) {
			$cell = $refHash_shapes->{$shape}->{mfe};
		}
		$HTML .= "<tr ".($refHash_shapes->{$shape}->{status} eq 'queued' ? "class='pending'" : "").">";
		$HTML .= "<td class='shapestring'>".$shape."</td>";
		$HTML .= "<td class='generation'>".printStatus(\%status_generation)."</td>";
		$HTML .= "<td class='execution'>".printStatus(\%status_execution)."</td>";
		$HTML .= "<td class='probability'>".(exists $refHash_shapes->{$shape}->{pfAnswer} ? sprintf("%.".$settings->{probdecimals}."f", $refHash_shapes->{$shape}->{pfAnswer}/$pfAll) : '?')." %</td>";
		$HTML .= "<td class='score'>".$cell."</td>";
		$HTML .= "<td class='pfvalue'>".(exists $refHash_shapes->{$shape}->{pfAnswer} ? $refHash_shapes->{$shape}->{pfAnswer} : '?')."</td>";
		$HTML .= "</tr>";
	}
	$HTML .= "</table>";
	
	$HTML .= "</body></html>";
	
	open (OUT, "> status.html");
		print OUT $HTML;
	close (OUT);
	#~ die;
	return $HTML;
}

sub printStatus {
	my ($refHash_status) = @_;
	return "<span class='".$refHash_status->{style}."'>".$refHash_status->{label}."</span>";
}



sub doComputation {
	my ($refHash_sequence, $settings) = @_;
	
	if ($refHash_sequence->{sequence} !~ m/^\s*((A|C|G|U|T)+)\s*$/i) {
		print STDERR "sequence '".$refHash_sequence->{header}."' has been skipped, due to non RNA letter. Only A,C,G,U,T,a,c,g,u,t are allowed.";
	}
	my $seq = $refHash_sequence->{sequence};
	$seq =~ s/t/u/gi;

	my $workingDirectory = qx(pwd); chomp $workingDirectory;
	my $oldTMPDir = $ENV{TMPDIR};
	$ENV{TMPDIR} = $Settings::RAPIDSHAPES_BIBISERV{clusterwide_tempdir};
	my $tmpdir = tempdir(CLEANUP => 1);
	$ENV{TMPDIR} = $oldTMPDir;

	#1) guess shape classes via stochastical backtracing (default) or simple shape analysis, where shapes are sorted according to their shrep free energy
	my @shapes = ();
	my %waitList = ();
	my $pfAll = undef;
	generateHTMLstatuspage($refHash_sequence, $settings, \%waitList, $pfAll);

	if ($settings->{mode} eq $Settings::MODE_KBEST) {
		@shapes = @{RapidShapes::guessShapesKbest($seq, $settings)};
	} elsif ($settings->{mode} eq $Settings::MODE_SUBOPT) {
		@shapes = @{RapidShapes::guessShapesSubopt($seq, $settings)};
	} elsif ($settings->{mode} eq $Settings::MODE_LIST) {
		@shapes = @{$settings->{list}};
		print STDERR "step 1: using a provided list of ".@shapes." shapes.\n";		
	} else {
		@shapes = @{RapidShapes::guessShapesSampling($seq, $settings)};
	}
	my $position = 1;
	foreach my $shape (@shapes) {
		my $shapestring = $shape->{shapestring};
		$waitList{$shapestring}->{position} = $position++;
		$waitList{$shapestring}->{status} = 'queued';
		delete $shape->{shapestring};
		foreach my $key (keys(%{$shape})) {
			$waitList{$shapestring}->{$key} = $shape->{$key};
		}
	}
	generateHTMLstatuspage($refHash_sequence, $settings, \%waitList, $pfAll);

	#2) determining partition function value for complete search space	
		$pfAll = RapidShapes::getPFall($seq, $settings, $workingDirectory);
		generateHTMLstatuspage($refHash_sequence, $settings, \%waitList, $pfAll);

	#3) compile TDM generator if not available
		print STDERR "step 3: compute exact probabilities for guessed shapes via grid engine ...\n";
		my $errDir = $tmpdir.'/ERR';
		my $outDir = $tmpdir.'/OUT';
		my $arrayJob =  $tmpdir.'/array.sh';
		my $shapeListFile = $tmpdir.'/shapelist.txt';
		qx(mkdir -p $errDir) if (not -d $errDir);
		qx(mkdir -p $outDir) if (not -d $outDir);
		open (SHAPELIST, "> ".$shapeListFile) || die "cannot write a file that shall contain all shapes to be computed: $1";
			foreach my $shape (sort {$waitList{$a}->{position} <=> $waitList{$b}->{position}} (keys(%waitList))) {
				print SHAPELIST $shape."\n";
			}
		close (SHAPELIST);
				
		open (ARRAY, "> ".$arrayJob) || die "cannot write to '$arrayJob': $1";		
			print ARRAY '#!'.$Settings::RAPIDSHAPES_BIBISERV{gridSH}."\n";
			print ARRAY ''."\n";
			print ARRAY '#$ -S '.$Settings::RAPIDSHAPES_BIBISERV{gridSH}."\n";
			print ARRAY '#$ -t 1-'.@shapes."\n";
			print ARRAY '#$ -N RapidShapes'."\n";
			print ARRAY '#$ -e '.$errDir."\n";
			print ARRAY '#$ -o '.$outDir."\n";
			print ARRAY ''."\n";
			print ARRAY 'header='.$refHash_sequence->{header}."\n";
			print ARRAY 'sequence='.$refHash_sequence->{sequence}."\n";
			print ARRAY 'shapestring=`'.$Settings::BINARIES{'head'}.' -n $SGE_TASK_ID '.$shapeListFile.' | '.$Settings::BINARIES{'tail'}.' -n 1`'."\n";
			print ARRAY $Settings::BINARIES{'uname'}.' -a 1>&2'."\n";
			my $command = "";
			$settings->{binarypath} = '/vol/fold-grammars/bin/';
			foreach my $param (keys %{$settings}) {
				next unless (
							($param eq 'temperature') ||
							($param eq 'param') ||
							($param eq 'allowlp') ||
							($param eq 'shapelevel') ||
							($param eq 'binarypath') ||
							($param eq 'binaryprefix') ||
							($param eq 'grammar')
						);
				$command .= " --".$RapidShapes::PARAM{$param}->{key}.'="'.$settings->{$param}.'"' if (defined $settings->{$param});
			}
			$command .= ' "$shapestring"';
			$command .= ' "$sequence"';
			print ARRAY $Settings::BINARIES{perl}." ".$Settings::RAPIDSHAPES_BIBISERV{tdmwrapper_binary}." ".$command."\n";
		close (ARRAY);
		my $qsubResult = qx($Settings::RAPIDSHAPES_BIBISERV{qsub} $arrayJob);
		($gridID) = ($qsubResult =~ m/Your job-array (\d+)/);
		
		my $sleepTime = $Settings::RAPIDSHAPES_BIBISERV{'sleepTimeInit'};
		my $pfSum = 0;
		while ($pfSum / $pfAll < $settings->{alpha}) {
			$pfSum = 0;
			foreach my $shapestring (keys(%waitList)) {
				if ($waitList{$shapestring}->{status} eq 'gotResult') {
					$pfSum += $waitList{$shapestring}->{pfAnswer};
					next;
				} else {
					my $errFile = $errDir."/RapidShapes.e".$gridID.".".$waitList{$shapestring}->{position};
					my $outFile = $outDir."/RapidShapes.o".$gridID.".".$waitList{$shapestring}->{position};
					if ((-e $errFile) && ($waitList{$shapestring}->{status} ne 'finish')) {
						open (ERR, $errFile) || die "can't read file '$errFile': $!";
							while (my $line = <ERR>) {
								if ($line =~ m/compiling \.\.\. (done in (.+?) seconds\.)?/) {
									$waitList{$shapestring}->{status} = "compiling";
									$waitList{$shapestring}->{compiletime} = $2 if (defined $2);
								} elsif ($line =~ m/running \.\.\. (done in (.+?) seconds\.)?/) {
									$waitList{$shapestring}->{status} = "running";
									$waitList{$shapestring}->{runtime} = $2 if (defined $2);
								} elsif ($line =~ m/^finished\.$/) {
									$waitList{$shapestring}->{status} = "finish";
								}
							}
						close (ERR);
					}
					if ((-e $outFile) && ($waitList{$shapestring}->{status} eq 'finish')) {
						my $pfAnswer = qx($Settings::BINARIES{cat} $outFile | $Settings::BINARIES{tail} -n 1); chomp $pfAnswer;
						$waitList{$shapestring}->{pfAnswer} = $pfAnswer;
						$waitList{$shapestring}->{status} = 'gotResult';
						$pfSum += $waitList{$shapestring}->{pfAnswer};
					}
				}
			}
			if ($pfSum / $pfAll >= $settings->{alpha}) {
				my $resDelGrid = qx($Settings::BINARIES{qdel} $gridID);
				print STDERR "abort grid job, because sufficient foldingspace has been explored.\n";
				foreach my $shape (keys(%waitList)) {
					$waitList{$shape}->{status} = 'stopped' if (not exists $waitList{$shape}->{pfAnswer});
				}
				last;
			}
			
			generateHTMLstatuspage($refHash_sequence, $settings, \%waitList, $pfAll);
			
			$sleepTime++ if ($sleepTime < $Settings::RAPIDSHAPES_BIBISERV{'sleepTimeMax'});
			sleep $sleepTime;
		}
		generateHTMLstatuspage($refHash_sequence, $settings, \%waitList, $pfAll);

		#output on console
			#Output Results the same way RNAshapes does
			print ">".$refHash_sequence->{header}."\n";
			print $refHash_sequence->{sequence}."\n";
			my $pfShapeSum = 0;
			foreach my $shapestring (keys(%waitList)) {
				delete $waitList{$shapestring} if (not exists $waitList{$shapestring}->{pfAnswer});
			}
			foreach my $shapestring (sort {$waitList{$b}->{pfAnswer} <=> $waitList{$a}->{pfAnswer}} (keys(%waitList))) {
				my $prob = 0;
				$prob = $waitList{$shapestring}->{pfAnswer} / $pfAll if ($pfAll != 0);
				print sprintf("%.$settings->{probdecimals}f", $prob)."  ".$shapestring."\n" if ($waitList{$shapestring}->{pfAnswer} != 0);
				$pfShapeSum += $prob;
			}
			#plus overall stop probability
			print "\n".sprintf("%.$settings->{probdecimals}f", $pfShapeSum / $pfAll)."  sum\n";
			print "\n";
}
